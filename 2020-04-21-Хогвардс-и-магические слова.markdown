Гарри Поттер идёт в первый класс Хогвартса.

Казалось бы, чего тут сложного -- выучил несколько колдовских слов, произнёс, и... никакого эффекта. 
Именно поэтому в специальных учебных заведениях наподобие Хогвартса вербальную магию изучают годами. 
Дело в том, что в волшебных учебниках написаны слова заклинания, которые сами по себе не работают. 
Их надо уметь преобразовывать в действующую магию с помощью специальных алгоритмов. 
Давайте познакомимся с одним из них.


У нас имеется не-магическое слово -- стандартная последовательность русских и английских букв (строковый тип). 
Такие слова в любом языке программирования можно сравнивать, используя обычный лексикографический порядок, 
когда "а" меньше чем "я", "a" меньше чем "z" и т. д.

Задача: преобразовать такое слово в магическое с помощью любого числа перестановок двух любых букв в слове, 
либо убедиться, что получить магическое слово невозможно.

Итоговое слово должно отвечать двум требованиям:
1) оно лексикографически больше, чем исходное слово;
2) оно наименьшее из всех лексикографически больших слов, которые можно получить перестановкой пары букв.

Тестовые примеры:

"ая" преобразовываем в "яа"
"fff" - невозможно преобразовать
"нклм" в "нкмл"
"вибк" в "викб"
"вкиб" в "ибвк"
Функция

string BiggerGreater(string input)
получает на вход исходную строку длиной 2 или более русских или английских строковых (маленьких) букв, 
и возвращает итоговое магическое слово. 
Если получить его невозможно, возвращается пустая строка.

Например, BiggerGreater("вибк") = "викб"; BiggerGreater("fff") = "".

Решение: 
Строка больше другой строки если она находится "правее" по алфавиту

Простое решение, которое потребует много времени и памяти:
- превратить строку в список S
- создать массив всех возможных перестановок букв в S (есть такие алгоритмы)
- все элементы этого массива превратить обратно в слова
- отсортироать массив слов по возрастанию
- найти там исходное слово
- взять ближайшего соседа "справа" (i+1)

этот способ однозначно плох, так как памяти требует немеряно, и пригоден только для малых строк

А вот способ посложнее и покороче:
сравнение строк, равных по размеру, похоже на поразрядное сравнение чисел (при этом числа равны по длине). 
	сначала сравнивается старший разряд (самая левая буква)
	если равны - переходим к следующему разряду
В этом свете, задачу можно представить как поиск наиболее близкого числа, состоящего из этих же цифр.
И вот первичные выводы:
- Очевидно, если цифры в числе уменьшаются (или равны) слева направо (число 9876543210 или 11111), 
то такое число преобразовать невозможно (все перестановки приведут только к уменьшению числа, 987>978 )
- Искомое число ТЕМ БЛИЖЕ к исходному, ЧЕМ МЛАДШЕ изменяемые разряды. Действительно, 
число 111132 и 111123 - самые близкие друг к другу из возможных вариантов

    Исходя из этого, а так же из того, что полученное слово должно быть БОЛЬШЕ исходного (то есть из 111123 в 111132 а не наоборот),
получаем последовательность действий:
- берем последнюю цифру (самый младший разряд) и меняем местами с соседом слева
  например 18765432 - 18765423
- сравниваем эти цифры. 
  Если слева Большее - то полученное число во-первых больше исходного, а во вторых является самым близким к исходному и поиск можно заканчивать.
  Если слева Меньшее, то исходное число уменьшилось и изменения теперь затронут более старший разряд. 
- Теперь цифру стоящую на предпоследнем месте надо менять с соседом слева. 18765423 - 18765243
  И опять сравнить только что поменянные цифры между собой.
- Из примера видно, что так мы и будем тащить эту злосчастную двойку влево до тех пор, пока она не встретит кого-нибудь меньше себя и таким 
  образом задача ьудет решена.
- Если эта цифра окажется самой младшей из имеющихся, то она в итоге займет самый старший разряд, а мы вернемся к остальным цифрам, стоящим в\
  том же порядке что и в начале (как будто от них отрезали этот младший разряд). 
- И все повторим. 
- начиная со второго круга, выполнение неравенства if S[i] < S[i-1] будет означать не окончание поиска, а только конец продвижения очередной 
  цифры из младшего разряда к старшему. 
- перед тем, как взяться за очередную цифру из младшего разряда, чтоб продвигать ее "влево", сравниваем полученное слово с исходным
- Наша программа справа налево ищет последовательность где цифры исходно расположены не убывая, а возрастая, и разворачивает ее. 
  если окажется что они все расположены по убыванию, то этот случай мы уже рассмотрели)
Ну и, финально, заменим слово "цифры" во всех этих рассуждениях на "буквы" и можно приступать к написанию кода)))


Код: 

import unittest
def BiggerGreater(input):
    S = list(input)
    if len(S) < 2 or S == sorted(S, reverse=True):
        return ''
    while ''.join(S) <= input:
        for i in range(- 1, -len(S), -1):
            S[i], S[i-1] = S[i-1], S[i]
            if S[i] < S[i-1] and ''.join(S) > input:
                break
            elif S[i] < S[i-1]:
                continue              
    return ''.join(S)

class MyTestCase(unittest.TestCase):    
    
    def test_1(self):
        a = BiggerGreater('ая')
        b = 'яа'
        self.assertEqual(a, b)    

    def test_2(self):
        a = BiggerGreater('нклм')
        b = 'нкмл'
        self.assertEqual(a, b)    
        
    def test_3(self):
        a = BiggerGreater('вибк')
        b = 'викб'
        self.assertEqual(a, b)    

    def test_4(self):
        a = BiggerGreater('вкиб')
        b = 'ибвк'
        self.assertEqual(a, b)    
if __name__ == '__main__':
    unittest.main()
