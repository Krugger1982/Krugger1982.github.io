Сегодня я расскажу как решал очередную задачу Курса - про матрицу, которую надо "провернуть"
Вот, собственно, условие:
К сожалению, никто не может объяснить, что такое Матрица.
Ты должен сам увидеть это.
На вход поступает Матрица размером MxN:

1 2 3 4 5 6 

2 3 4 5 6 7 

3 4 5 6 7 8 

4 5 6 7 8 9 

Ты должен научиться вращать Матрицу относительно её центра по часовой стрелке.

Например, вращение на один шаг:

2 1 2 3 4 5  

3 4 3 4 5 6 

4 5 6 7 6 7 

5 6 7 8 9 8 

Функция

void MatrixTurn(string Matrix[], int M, int N, int T)
получает на вход (по ссылке) массив строк (M строк, каждая длиной N; M >= 2, N >= 2), 
и вращает его относительно центра по часовой стрелке на T шагов (T >= 1), как описано выше.
Минимальное значение из чисел M,N обязательно чётно.

Пример вызова:

MatrixTurn(["123456", "234567", "345678", "456789"], 4,6, 3)

Решение: по шагам.
1) Придумываем некий абстрактный образ, иллюстрирующий данное задание. Например, чтоб не возиться
 со скучными цифрами, представим матрицу, которую надо повернуть, в виде некоего тонкого шкива (или двух), 
 на который  натянута гусеничная лента, состоящая из единичных траков. На каждом траке нанесен некий символ 
 буква, цифра, цветочек, фигурка животного и т.д.)
 Поверх этой "гусеницы" натянута еще одна, тоже состоящая из единичных траков, тоже с узорами. 
 И Еще. И еще. Пока не получим прямоугольник(или квадрат, если изначально шкив один) со сторонами М и N. 
2) Теперь попробуем описать словами это вращение на Т шагов. Каждая гусеница должна "провернуться" на эти Т шагов
 по часовой стрелке.
 Что это значит? Внешнюю гусеницу снимаем, разворачиваем в линию, "отрезаем" справа Т траков и "приклеиваем" их слева.
 Так же поступаем со всеми внутренними "гусеницами", пока не оголится шкив.
 Разница R между длинами периметров будет равна   2(N-M), если матрица вытянута в длину (если N > M) 
   	  					  2(M-N), если матрица вытянута в высоту (если M > N)
						  0, если матрица квадратная (M = N)
 Всего периметров будет N/2, где N - меньшая сторона
3) "Собираем" эту "катушку" обратно, то есть последовательно от малого к большему "надеваем" "провернутые" гусеницы.
Рассмотрим сначала вытянутую горизонтально матрицу, т.н. N < M, и N - четное число.
 Математически это можно представить так:
	1 этап:
а)Создается первый список.  В него заносятся 
   	1. все члены верхней строки матрицы. 
	2. Потом все последние члены строк, то есть правый столбец (кроме  первой и последней строки). 
	3. Затем в обратном порядке - нижняя строка. 
	4. Затем, в обратном порядке - первые члены строк (кроме М-й и 0-й строки). 
Если остались только 0-я и М-я строки,(N = 2), тогда для внутреннего периметра реализуем свой особый алгоритм:
        1.  Записываем верхнюю строку,
	2. В обратном порядке записываем нижнюю строку.
Получим таким образом список, в котором собран один периметр.  Все элементы, занесенные в этот список, 
из матрицы удаляются (мы сдираем с нее внешний слой), остается матрица   размером М-2, N-2.
б) Повторяем со следующим слоем до тех пор, пока М или N не станет равной 0 (осталась "пустая" матрица)
	2 этап:
 С каждым списком (периметром) проводим мероприятия по "проворачиванию" его на Т шагов ("отрезаем" Т последних элементов и вставляем в начало списка)
	3 этап:
Сборка матрицы будет в обратном порядке. 
Сначала берем внутренний периметр(j = 0). Его длина будет равна 2(R + 2) = 2(M - N + 2)
 Первые R+2 элементов записываем в верхнюю строку. Вторые -  в нижнюю строку в обратном порядке.
Второй  периметр(j=1): длина P = 2(R+2)+8 (так как каждая сторона увелиыилась на 2 единицы)
- добавляем и заполняем первую строку (длиной R + 4)				i = 0 ... R+3
- в следующие уже имеющиеся строки добавляем по одному элементу			i = R+4 ... R+5 
- добавляем и заполняем последнюю строку (длиной R + 4, 			i = R+6 ... 2R+7
- в строки снизу вверх (кроме последней и нулевой) вставляем первый элемент	i = 2R+8...2R+9

j-тый периметр: длина равна 2(M-N+2)+8j.					
- добавляем и заполняем первую строку (длиной R+2+2j)				i = 0 ... R+2+2j-1
- в следующие уже имеющиеся строки добавляем по одному элементу			i = R+2+2j ... R+4j+2-1 
- добавляем и заполняем последнюю строку (длиной R + 2 + 2i)в обратном порядке	i = R+4j+2 ... 2R+6j+4-1
- в строки снизу вверх (кроме последней и нулевой) вставляем первый элемент	i = 2R+6j+4 ... 2R+8j+4-1
повторяем эту сборку 
Повторяем эту последовательность N/2 раз.

Для матрицы, которая вытянута вверх (N > M и М - четное число)
1)Разборка матрицы на периметры - такая же
2) проворот периметров такой же
3) Сборка:
	Первый периметр: 	- 1-я строка длиной 2 		(i = 0, i = 1)
				- правый столбец длиной R 	(i = 3 ... i = 2+R)
				- последняя строка длиной 2 	(i = 2+R+1 ... i = 2+R+2) заполняется в обратном порядке
				- первый столбец длиной R 	(i = 2+R+3 ... i = 2+2R+3) заполняется снизу вверх

	j-тый периметр:		- 1-я строка длиной (2j)   					i = 0, ... 2j+2-1
				- последний столбец длиной R+2j-2				i = 2j+2 ... R+4j+2-1
				- последняя строка длиной(2+2j)заполняется в обратном порядке	i = R+4j+2 ... R+6j+4-1
				- первый столбец длиной R+2j заполняется снизу вверх 		i = R+6j+4 ... 2R+8j+4-1

Профит!
