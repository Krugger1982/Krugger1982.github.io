Сегодня я расскажу как решал очередную задачу Курса - про матрицу, которую надо "провернуть"
Вот, собственно, условие:
К сожалению, никто не может объяснить, что такое Матрица.
Ты должен сам увидеть это.
На вход поступает Матрица размером MxN:

1 2 3 4 5 6 
2 3 4 5 6 7
3 4 5 6 7 8
4 5 6 7 8 9
Ты должен научиться вращать Матрицу относительно её центра по часовой стрелке.

Например, вращение на один шаг:

2 1 2 3 4 5 
3 4 3 4 5 6
4 5 6 7 6 7
5 6 7 8 9 8
Функция

void MatrixTurn(string Matrix[], int M, int N, int T)
получает на вход (по ссылке) массив строк (M строк, каждая длиной N; M >= 2, N >= 2), 
и вращает его относительно центра по часовой стрелке на T шагов (T >= 1), как описано выше.
Минимальное значение из чисел M,N обязательно чётно.

Пример вызова:

MatrixTurn(["123456", "234567", "345678", "456789"], 4,6, 3)

Решение: по шагам.
1) Придумываем некий абстрактный образ, иллюстрирующий данное задание. Например, чтоб не возиться
 со скучными цифрами, представим матрицу, которую надо повернуть, в виде некоего тонкого шкива (или двух), 
 на который  натянута гусеничная лента, состоящая из единичных траков. На каждом траке нанесен некий символ 
 буква, цифра, цветочек, фигурка животного и т.д.)
 Поверх этой "гусеницы" натянута еще одна, тоже состоящая из единичных траков, тоже с узорами. 
 И Еще. И еще. Пока не получим прямоугольник(или квадрат, если изначально шкив один) со сторонами М и N. 
2) Теперь попробуем описать словами это вращение на Т шагов. Каждая гусеница должна "провернуться" на эти Т шагов
 по часовой стрелке.
 Что это значит? Внешнюю гусеницу снимаем, разворачиваем в линию, "отрезаем" справа Т траков и "приклеиваем" их слева.
 Так же поступаем со всеми внутренними "гусеницами", пока не оголится шкив.
 Разница R между длинами периметров будет равна   2(N-M), если матрица вытянута в длину (если N > M) 
   	  					  2(M-N), если матрица вытянута в высоту (если M > N)
						  0, если матрица квадратная (M = N)
 Всего периметров будет N/2, где N - меньшая сторона
3) "Собираем" эту "катушку" обратно, то есть последовательно от малого к большему "надеваем" "провернутые" гусеницы.
Рассмотрим сначала вытянутую горизонтально матрицу, т.н. N < M, и N - четное число.
 Математически это можно представить так:
	1 этап:
а)Создается первый список.  В него заносятся 
   	1. все члены верхней строки матрицы. 
	2. Потом все последние члены строк, то есть правый столбец (кроме  первой и последней строки). 
	3. Затем в обратном порядке - нижняя строка. 
	4. Затем, в обратном порядке - первые члены строк (кроме М-й и 0-й строки). 
Если остались только 0-я и М-я строки,(N = 2), тогда для внутреннего периметра реализуем свой особый алгоритм:
        1.  Записываем верхнюю строку,
	2. В обратном порядке записываем нижнюю строку.
Получим таким образом список, в котором собран один периметр.  Все элементы, занесенные в этот список, 
из матрицы удаляются (мы сдираем с нее внешний слой), остается матрица   размером М-2, N-2.
б) Повторяем со следующим слоем до тех пор, пока М или N не станет равной 0 (осталась "пустая" матрица)
	2 этап:
 С каждым списком (периметром) проводим мероприятия по "проворачиванию" его на Т шагов ("отрезаем" Т последних элементов и вставляем в начало списка)
	3 этап:
Сборка матрицы будет в обратном порядке. 
Сначала берем внутренний периметр(j = 0). Его длина будет равна 2(R + 2) = 2(M - N + 2)
 Первые R+2 элементов записываем в верхнюю строку. Вторые -  в нижнюю строку в обратном порядке.
Второй  периметр(j=1): длина P = 2(R+2)+8 (так как каждая сторона увелиыилась на 2 единицы)
- добавляем и заполняем первую строку (длиной R + 4)				i = 0 ... R+3
- в следующие уже имеющиеся строки добавляем по одному элементу			i = R+4 ... R+5 
- добавляем и заполняем последнюю строку (длиной R + 4, 			i = R+6 ... 2R+7
- в строки снизу вверх (кроме последней и нулевой) вставляем первый элемент	i = 2R+8...2R+9

j-тый периметр: длина равна 2(M-N+2)+8j.					
- добавляем и заполняем первую строку (длиной R+2+2j)				i = 0 ... R+2+2j-1
- в следующие уже имеющиеся строки добавляем по одному элементу			i = R+2+2j ... R+4j+2-1 
- добавляем и заполняем последнюю строку (длиной R + 2 + 2i)в обратном порядке	i = R+4j+2 ... 2R+6j+4-1
- в строки снизу вверх (кроме последней и нулевой) вставляем первый элемент	i = 2R+6j+4 ... 2R+8j+4-1
повторяем эту сборку 
Повторяем эту последовательность N/2 раз.

Для матрицы, которая вытянута вверх (N > M и М - четное число)
1)Разборка матрицы на периметры - такая же
2) проворот периметров такой же
3) Сборка:
	Первый периметр: 	- 1-я строка длиной 2 		(i = 0, i = 1)
				- правый столбец длиной R 	(i = 3 ... i = 2+R)
				- последняя строка длиной 2 	(i = 2+R+1 ... i = 2+R+2) заполняется в обратном порядке
				- первый столбец длиной R 	(i = 2+R+3 ... i = 2+2R+3) заполняется снизу вверх

	j-тый периметр:		- 1-я строка длиной (2j)   					i = 0, ... 2j+2-1
				- последний столбец длиной R+2j-2				i = 2j+2 ... R+4j+2-1
				- последняя строка длиной(2+2j)заполняется в обратном порядке	i = R+4j+2 ... R+6j+4-1
				- первый столбец длиной R+2j заполняется снизу вверх 		i = R+6j+4 ... 2R+8j+4-1

Профит!
 


import random
def  MatrixTurn(Matrix, M, N, T):
    A = []
    for i in range(len(Matrix)):
        A.append(list(Matrix[i]))
    perimetr = []
    temp = []
    while len(A) > 2 and len (A[0]) > 2:       # Разбираем матрицу на "периметры"
        for i in range(len(A[0])):
            temp.append(A[0][i])
        del A[0]
        for i in range(len(A)-1):
            temp.append(A[i][len(A[i])-1])
            del A[i][len(A[i])-1]
        for i in range(-1, -len(A[len(A)-1])-1, -1):
            temp.append(A[len(A)-1][i])
        del A[len(A)-1]
        for i in range(-1, -len(A)-1, -1):
            temp.append(A[i][0])
            del A[i][0]
        perimetr.append(temp)
        temp = []
    if N <= M:                                    # Последний периметр, состоящий из 2-х строк - горизонтальный
        for i in range(len(A[0])):
            temp.append(A[0][i])
        del A[0]
        for i in range(-1, -len(A[0])-1, -1):
            temp.append(A[0][i])
        del A[0]
    else:                                         # и вертикальный, состоящий из 2х столбцов
        temp.append(A[0][0])
        for i in range(len(A)):
            temp.append(A[i][1])
            del A[i][1]
        for i in range(-1, -len(A), -1):
            temp.append(A[-1][0])
            del A[i]
        del A[0]
    perimetr.append(temp)
    perimetr.reverse()
    for i in range(len(perimetr)):            #Проворачиваем каждую линию "периметра"
        for j in range(T):                    # на Т шагов (если Т = 0, то они не провернутся)
            perimetr[i].insert(0, perimetr[i].pop())
    A = []                  # Сборка повернутой матрицы производится в обратном порядке - от внутрених слоев к внешним
    if N <= M:                                                  # Для горизнтальной или квадратной матрицы
        R = M - N
        A.append([]) 
        A.append([])
        for j in range(len(perimetr)):
            if j == 0:                                          # заполняем внутренний периметр (только 2 строки)
                z = len(perimetr[0])
                for i in range(len(perimetr[0])):
                    if i < z//2:
                        A[0].append(perimetr[0][i])
                    else:
                        A[1].insert(0, perimetr[0][i])
            else:                                              # Заполняем следующие периметры
                A.insert(0, [])
                A.append([])
                for i in range(len(perimetr[j])):              # Верхняя строка
                    if i < R + 2 * j + 2:
                        A[0].append(perimetr[j][i])
                    elif i < R + 4 * j + 2:                    # Правый столбец
                        A[i - (R + 2 * j + 2 - 1)].append(perimetr[j][i])
                    elif i < (2 * R + 6 * j + 4):
                        A[len(A)-1].insert(0, perimetr[j][i])  # нижняя строка
                    else:
                        A[-(i - (2 * R + 6 * j + 4) + 2)].insert(0, perimetr[j][i])   # Левый столбец  
    else:                                                       # Для матрицы, вытянутой ветикально
        R = N - M
        for i in range (len(perimetr[0])//2):
            A.append([])
        for j in range(len(perimetr)):
            if j == 0:                                          # заполняем внутренний периметр (только 2 строки)
                for i in range(len(perimetr[0])):
                    if i == 0:
                        A[0].append(perimetr[j][0])
                    elif i < (len(perimetr[0])//2+1):
                        A[i-1].append(perimetr[0][i])
                    else:
                        A[-(i - 2 * R - 1)].insert(0, perimetr[0][i]) 
            else:
                A.insert(0, [])
                A.append([])
                for i in range(len(perimetr[j])):                             # Верхняя строка
                    if i < 2 * j + 2:
                        A[0].append(perimetr[j][i])
                    elif i < R + 4 * j + 2:                                   # Правый столбец
                        A[i - ( 2 * j + 2 - 1)].append(perimetr[j][i])
                    elif i < (R + 6 * j + 4):
                        A[len(A)-1].insert(0, perimetr[j][i])                 # нижняя строка
                    else:
                        A[-(i - (R + 6 * j + 2))].insert(0, perimetr[j][i])   # Левый столбец                  
    for i in range(len(A)):
        A[i] = ''.join(A[i])
    return A

N = 4
M = 4
B = []                             # формируем матрицу B
for i in range(N): 
    b = [] 
    for j in range(M):  
        b.append(str(random.randint(0,9)))  
    B.append(''.join(b))  
    
print ("Матрица B")                   # выводим матрицу B
for i in range(N):
    print (' ',B[i])
    
ring = MatrixTurn(B, M, N, 1)
for i in range(len(ring)):
    print(ring[i])
